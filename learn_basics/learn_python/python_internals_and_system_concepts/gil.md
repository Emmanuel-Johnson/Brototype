The Global Interpreter Lock (GIL) in CPython is a mutex that allows only one thread to execute Python bytecode at a time, even on multi-core processors, mainly because CPython uses reference counting for memory management, and without the GIL multiple threads updating an object’s reference count could corrupt memory. A thread must acquire the GIL before running Python code and it releases it after a short interval or during I/O operations. This means CPU-bound tasks don’t benefit from multithreading—threads just wait for the GIL, causing no speedup and sometimes even slowdown—while I/O-bound tasks (network, file, database) run efficiently because the GIL is released during waiting. To bypass the GIL, we use multiprocessing for CPU-heavy work (each process has its own GIL), threading or asyncio for I/O-bound tasks, or C extensions like NumPy that release the GIL internally. With Python 3.13+, an experimental no-GIL build also exists, moving towards true multithreaded performance in future versions.
